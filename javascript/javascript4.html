<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anton Codder - Advanced JavaScript Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/box.css">
</head>
<body>

    <header class="header">
        <h1>Anton Codder - JavaScript Tutorials</h1>
        <p>Welcome to Anton's JavaScript Tutorials. Select a tutorial below to learn more!</p>
    </header>

    <div class="container">
    <div class="code-container">
    <div class="code-header">
        <h3>1. Currying and Partial Application</h3>
    </div>
    <pre><code class="language-javascript">
// Currying: Fungsi yang menghasilkan fungsi baru dengan parameter yang telah diberikan sebelumnya
const multiply = x => y => x * y;

const multiplyBy2 = multiply(2);
console.log(multiplyBy2(5)); // 10
console.log(multiplyBy2(10)); // 20

// Partial application: Menyediakan sebagian parameter fungsi sebelumnya
const greet = (greeting, name) => `${greeting}, ${name}!`;
const greetHello = greet.bind(null, 'Hello');
console.log(greetHello('Anton')); // Hello, Anton!
    </code></pre>
    <p>Penjelasan: Currying memungkinkan kita untuk membuat fungsi yang lebih spesifik dengan mengubah parameter secara bertahap, sementara partial application mengurangi kebutuhan untuk memasukkan parameter yang sama berulang kali.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>2. Deep Clone Object</h3>
    </div>
    <pre><code class="language-javascript">
// Deep clone menggunakan JSON.parse dan JSON.stringify
const person = {
    name: 'Anton',
    address: {
        city: 'Jakarta',
        country: 'Indonesia'
    }
};

const clonePerson = JSON.parse(JSON.stringify(person));
clonePerson.address.city = 'Bandung';
console.log(person.address.city); // Jakarta
console.log(clonePerson.address.city); // Bandung
    </code></pre>
    <p>Penjelasan: Deep clone digunakan untuk membuat salinan objek yang baru, termasuk semua objek yang bersarang di dalamnya, tanpa merujuk ke objek asli.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>3. Implementing a Simple Event Emitter</h3>
    </div>
    <pre><code class="language-javascript">
// Menyusun event emitter sederhana
class EventEmitter {
    constructor() {
        this.events = {};
    }

    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    emit(event, ...args) {
        if (this.events[event]) {
            this.events[event].forEach(listener => listener(...args));
        }
    }
}

const emitter = new EventEmitter();
emitter.on('greet', name => console.log(`Hello, ${name}`));
emitter.emit('greet', 'Anton'); // Hello, Anton
    </code></pre>
    <p>Penjelasan: EventEmitter adalah pola yang memungkinkan kita untuk memicu event dan mendengarkan event tertentu. Ini berguna dalam pengembangan aplikasi berbasis event.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>4. Infinite Scroll with Intersection Observer</h3>
    </div>
    <pre><code class="language-javascript">
// Menggunakan Intersection Observer untuk infinite scroll
const loadMoreItems = () => {
    console.log('Loading more items...');
    // Logika untuk memuat data lebih banyak (misalnya fetch dari API)
};

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            loadMoreItems();
        }
    });
}, {
    rootMargin: '100px',
});

const target = document.querySelector('#loadMore');
observer.observe(target);
    </code></pre>
    <p>Penjelasan: Intersection Observer memungkinkan kita untuk memantau elemen yang muncul atau menghilang dari tampilan, berguna untuk mengimplementasikan infinite scroll.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>5. Async/Await with Error Handling</h3>
    </div>
    <pre><code class="language-javascript">
// Menggunakan async/await dengan penanganan error
const fetchData = async () => {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
};

fetchData();
    </code></pre>
    <p>Penjelasan: async/await digunakan untuk bekerja dengan promise secara lebih mudah, dan blok try-catch digunakan untuk menangani error yang mungkin terjadi.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>6. Custom Iterator</h3>
    </div>
    <pre><code class="language-javascript">
// Membuat iterator kustom untuk objek
const range = {
    from: 1,
    to: 5,
    [Symbol.iterator]() {
        let current = this.from;
        let last = this.to;
        return {
            next() {
                if (current <= last) {
                    return { value: current++, done: false };
                } else {
                    return { done: true };
                }
            }
        };
    }
};

for (let num of range) {
    console.log(num); // 1, 2, 3, 4, 5
}
    </code></pre>
    <p>Penjelasan: Iterator kustom memungkinkan kita untuk mendefinisikan bagaimana sebuah objek harus diiterasi, memberikan fleksibilitas lebih dalam manipulasi data.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>7. Custom Hooks in JavaScript (React-like)</h3>
    </div>
    <pre><code class="language-javascript">
// Membuat custom hook untuk mengelola state
function useState(initialValue) {
    let value = initialValue;
    const getValue = () => value;
    const setValue = (newValue) => value = newValue;
    return [getValue, setValue];
}

const [count, setCount] = useState(0);
console.log(count()); // 0
setCount(5);
console.log(count()); // 5
    </code></pre>
    <p>Penjelasan: Custom hooks memungkinkan kita untuk mengelola state atau logika lain dengan cara yang terpisah, mirip dengan hook di React.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>8. Proxy for Observing Changes</h3>
    </div>
    <pre><code class="language-javascript">
// Menggunakan Proxy untuk memantau perubahan pada objek
const handler = {
    set(target, property, value) {
        console.log(`Setting ${property} to ${value}`);
        target[property] = value;
        return true;
    }
};

const person = new Proxy({}, handler);
person.name = 'Anton'; // Setting name to Anton
console.log(person.name); // Anton
    </code></pre>
    <p>Penjelasan: Proxy memungkinkan kita untuk mendefinisikan perilaku kustom untuk operasi dasar seperti pembacaan dan penulisan properti pada objek.</p>
</div>

<div class="code-container">
    <div class="code-header">
        <h3>9. Code Splitting with Dynamic Imports</h3>
    </div>
    <pre><code class="language-javascript">
// Dynamic import untuk code splitting
const loadLibrary = async () => {
    const { default: lodash } = await import('lodash');
    console.log(lodash.join(['Hello', 'world'], ' '));
};

loadLibrary();
    </code></pre>
    <p>Penjelasan: Code splitting memungkinkan kita untuk memuat hanya bagian kode yang dibutuhkan pada waktu tertentu, mengurangi ukuran bundle dan meningkatkan performa aplikasi.</p>
</div>

</div>
    <footer class="footer">
        <p>&copy; 2024 Anton Codder. Semua Hak Cipta Dilindungi. Dibuat dengan ketelitian oleh Anton</p>
    </footer>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>
    <script src="../assets/js/script.js"></script>
</body>
</html>