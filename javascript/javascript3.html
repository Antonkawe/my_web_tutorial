<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anton Codder - Advanced JavaScript Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="../assets/css/box.css">
</head>
<body>

    <header class="header">
        <h1>Anton Codder - JavaScript Tutorials</h1>
        <p>Welcome to Anton's JavaScript Tutorials. Select a tutorial below to learn more!</p>
    </header>

    <div class="container">
        <div class="code-container">
            <div class="code-header">
                <h3>1. Handling Multiple Promises with Promise.all</h3>
            </div>
            <pre><code class="language-javascript">
// Menggunakan Promise.all untuk menangani beberapa promise secara bersamaan
const fetchData1 = new Promise((resolve) => setTimeout(() => resolve("Data 1"), 2000));
const fetchData2 = new Promise((resolve) => setTimeout(() => resolve("Data 2"), 3000));
const fetchData3 = new Promise((resolve) => setTimeout(() => resolve("Data 3"), 1000));

Promise.all([fetchData1, fetchData2, fetchData3])
  .then(values => {
    console.log(values); // ["Data 1", "Data 2", "Data 3"]
  })
  .catch(error => console.log("Error:", error));
            </code></pre>
            <p>Penjelasan: `Promise.all` memungkinkan kita untuk menangani beberapa promise secara bersamaan. Hasilnya adalah array yang berisi nilai-nilai dari setiap promise yang berhasil diselesaikan. Semua promise harus selesai dengan sukses agar `then` dipanggil.</p>
        </div>

        <!-- Section 2: Generators in JavaScript -->
        <div class="code-container">
            <div class="code-header">
                <h3>2. Generators in JavaScript</h3>
            </div>
            <pre><code class="language-javascript">
// Generator function untuk menghasilkan nilai secara berurutan
function* myGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

const generator = myGenerator();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }
            </code></pre>
            <p>Penjelasan: Generator function memungkinkan kita untuk menunda eksekusi dan mengembalikan nilai secara bertahap menggunakan `yield`. `next()` dipanggil untuk mendapatkan nilai berikutnya, dan objek yang dikembalikan memiliki properti `value` dan `done`.</p>
        </div>

        <!-- Section 3: Web APIs and Fetching Data -->
        <div class="code-container">
            <div class="code-header">
                <h3>3. Web APIs: Fetching Data from a REST API</h3>
            </div>
            <pre><code class="language-javascript">
// Mengambil data dari API dengan Web API fetch
fetch('https://jsonplaceholder.typicode.com/posts')
  .then(response => response.json()) // Mengonversi ke format JSON
  .then(posts => console.log(posts)) // Menampilkan data
  .catch(error => console.log('Error:', error));
            </code></pre>
            <p>Penjelasan: `fetch` adalah Web API untuk mengambil data dari server. Fungsi ini mengembalikan promise yang akan diselesaikan dengan respons dari server. Kita mengonversi respons menjadi JSON untuk memudahkan manipulasi data.</p>
        </div>

        <!-- Section 4: Event Loop in JavaScript -->
        <div class="code-container">
            <div class="code-header">
                <h3>4. Event Loop and Execution Context</h3>
            </div>
            <pre><code class="language-javascript">
// Memahami Event Loop dan Execution Context
console.log("Start");

setTimeout(() => {
    console.log("Inside setTimeout");
}, 0);

console.log("End");
            </code></pre>
            <p>Penjelasan: JavaScript memiliki event loop yang menangani asynchronous tasks. Dalam contoh ini, meskipun `setTimeout` diatur untuk dieksekusi setelah 0 ms, ia tetap dimasukkan dalam task queue dan baru dieksekusi setelah call stack kosong.</p>
        </div>

        <!-- Section 5: Deep Dive into Closures -->
        <div class="code-container">
            <div class="code-header">
                <h3>5. Deep Dive into Closures</h3>
            </div>
            <pre><code class="language-javascript">
// Memahami closures dengan lebih dalam
function outer() {
    let count = 0;
    return function inner() {
        count++;
        console.log(count);
    };
}

const counter = outer();
counter(); // 1
counter(); // 2
counter(); // 3
            </code></pre>
            <p>Penjelasan: Closure terjadi ketika sebuah fungsi mengakses variabel yang ada di luar ruang lingkupnya. Pada contoh ini, fungsi `inner` terus mengakses variabel `count` meskipun `outer` telah selesai dieksekusi, menghasilkan counter yang bertambah setiap kali dipanggil.</p>
        </div>

        <!-- Section 6: Debouncing and Throttling -->
        <div class="code-container">
            <div class="code-header">
                <h3>6. Debouncing and Throttling</h3>
            </div>
            <pre><code class="language-javascript">
// Implementasi debounce untuk input search
let debounceTimer;
function debounce(func, delay) {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(func, delay);
}

function onSearch() {
    console.log("Search triggered");
}

document.getElementById("searchInput").addEventListener('input', () => {
    debounce(onSearch, 500); // Fungsi hanya akan dipanggil setelah 500ms
});
            </code></pre>
            <p>Penjelasan: Debouncing digunakan untuk menunda eksekusi fungsi hingga beberapa waktu setelah aksi terakhir dilakukan. Ini berguna untuk mengoptimalkan event seperti input pengguna, di mana kita tidak perlu mengeksekusi fungsi berulang kali selama input terjadi.</p>
        </div>

        <!-- Section 7: Error Handling with Async/Await -->
        <div class="code-container">
            <div class="code-header">
                <h3>7. Error Handling with Async/Await</h3>
            </div>
            <pre><code class="language-javascript">
// Menggunakan try-catch dengan async/await untuk menangani error
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Error fetching data:", error);
    }
}
fetchData();
            </code></pre>
            <p>Penjelasan: `async/await` membuat penanganan asynchronous lebih mudah dipahami. Dengan `try-catch`, kita dapat menangani error saat mengambil data dari API dengan cara yang lebih bersih dan terstruktur.</p>
        </div>

        <!-- Section 8: Custom Event Listeners -->
        <div class="code-container">
            <div class="code-header">
                <h3>8. Custom Event Listeners</h3>
            </div>
            <pre><code class="language-javascript">
// Menambahkan custom event listener
const button = document.getElementById("myButton");

button.addEventListener("click", function() {
    alert("Button clicked!");
});
            </code></pre>
            <p>Penjelasan: Kita bisa menambahkan event listener untuk berbagai macam event, seperti `click`, `keydown`, dll. Di sini, kita menambahkan event listener ke sebuah tombol sehingga saat tombol diklik, sebuah alert akan muncul.</p>
        </div>

        <!-- Section 9: The Fetch API and Async Data -->
        <div class="code-container">
            <div class="code-header">
                <h3>9. The Fetch API and Async Data</h3>
            </div>
            <pre><code class="language-javascript">
// Fetch API dan pengolahan data JSON secara asynchronous
async function getUserData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        const users = await response.json();
        console.log(users);
    } catch (error) {
        console.log("Error:", error);
    }
}
getUserData();
            </code></pre>
            <p>Penjelasan: Dengan `fetch` dan `async/await`, kita dapat mengambil data secara asynchronous dengan cara yang mudah dimengerti. Jika berhasil, kita memproses data JSON; jika tidak, kita menangani error dengan `catch`.</p>
        </div>

        <!-- Section 10: Working with LocalStorage -->
        <div class="code-container">
            <div class="code-header">
                <h3>10. Working with LocalStorage</h3>
            </div>
            <pre><code class="language-javascript">
// Menyimpan dan mengambil data dari LocalStorage
localStorage.setItem("username", "Anton");

const username = localStorage.getItem("username");
console.log(username); // Anton

// Menghapus item dari LocalStorage
localStorage.removeItem("username");
            </code></pre>
            <p>Penjelasan: `localStorage` adalah cara untuk menyimpan data di browser yang dapat bertahan bahkan setelah halaman dimuat ulang. Kita dapat menyimpan data menggunakan `setItem`, mengambilnya dengan `getItem`, dan menghapusnya dengan `removeItem`.</p>
        </div>

        <!-- Section 11: JavaScript Modules -->
        <div class="code-container">
            <div class="code-header">
                <h3>11. JavaScript Modules</h3>
            </div>
            <pre><code class="language-javascript">
// Menggunakan JavaScript modules untuk impor dan ekspor fungsi
// File: math.js
export function add(a, b) {
    return a + b;
}

export function subtract(a, b) {
    return a - b;
}

// File: app.js
import { add, subtract } from './math.js';

console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3
            </code></pre>
            <p>Penjelasan: Dengan JavaScript modules, kita bisa membagi kode menjadi file terpisah untuk organisasi yang lebih baik. `export` digunakan untuk mengekspor fungsi atau variabel, dan `import` digunakan untuk mengimpor kode dari modul lain.</p>
        </div>

        <!-- Section 12: Understanding Promises and Chaining -->
        <div class="code-container">
            <div class="code-header">
                <h3>12. Understanding Promises and Chaining</h3>
            </div>
            <pre><code class="language-javascript">
// Menggunakan Promise dan chaining untuk menangani operasi asynchronous
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Data fetched");
    }, 2000);
});

fetchData
    .then(result => {
        console.log(result); // "Data fetched"
        return "Processing data";
    })
    .then(processedData => {
        console.log(processedData); // "Processing data"
    })
    .catch(error => console.log("Error:", error));
            </code></pre>
            <p>Penjelasan: Chaining dengan `then` memungkinkan kita untuk menangani hasil dari promise secara berurutan. Setiap `then` menerima nilai yang dikembalikan dari promise sebelumnya dan mengembalikan promise baru jika diperlukan.</p>
        </div>

        <!-- Section 13: Asynchronous JavaScript with Async/Await -->
        <div class="code-container">
            <div class="code-header">
                <h3>13. Asynchronous JavaScript with Async/Await</h3>
            </div>
            <pre><code class="language-javascript">
// Menangani operasi asynchronous menggunakan async/await
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.log("Error:", error);
    }
}
fetchData();
            </code></pre>
            <p>Penjelasan: Dengan `async/await`, kita bisa menulis kode asynchronous dengan cara yang lebih bersih dan mudah dibaca. `await` digunakan untuk menunggu promise diselesaikan, dan `async` menandakan bahwa fungsi tersebut mengandung operasi asynchronous.</p>
        </div>

        <!-- Section 14: Working with Date and Time -->
        <div class="code-container">
            <div class="code-header">
                <h3>14. Working with Date and Time in JavaScript</h3>
            </div>
            <pre><code class="language-javascript">
// Menggunakan objek Date untuk bekerja dengan tanggal dan waktu
const now = new Date();
console.log(now); // Menampilkan tanggal dan waktu saat ini

const birthday = new Date("2000-01-01");
console.log(birthday); // Menampilkan tanggal ulang tahun

const daysBetween = Math.floor((now - birthday) / (1000 * 60 * 60 * 24));
console.log(`Days since birth: ${daysBetween}`);
            </code></pre>
            <p>Penjelasan: Objek `Date` memungkinkan kita untuk bekerja dengan tanggal dan waktu. Kita bisa membuat objek `Date` baru, menghitung perbedaan waktu antara dua tanggal, dan mengonversi tanggal menjadi format yang lebih mudah dipahami.</p>
        </div>

        <!-- Section 15: JavaScript Design Patterns -->
        <div class="code-container">
            <div class="code-header">
                <h3>15. JavaScript Design Patterns</h3>
            </div>
            <pre><code class="language-javascript">
// Singleton Pattern untuk memastikan hanya ada satu instance dari objek
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        this.value = Math.random();
        Singleton.instance = this;
    }
}

const singleton1 = new Singleton();
const singleton2 = new Singleton();

console.log(singleton1 === singleton2); // true
            </code></pre>
            <p>Penjelasan: Design pattern Singleton memastikan hanya ada satu instance dari sebuah kelas. Ini sangat berguna ketika kita ingin mengelola akses ke sumber daya yang terbatas, seperti koneksi database atau konfigurasi aplikasi.</p>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2024 Anton Codder. Semua Hak Cipta Dilindungi. Dibuat dengan ketelitian oleh Anton</p>
    </footer>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>
    <script src="../assets/js/script.js"></script>
</body>
</html>